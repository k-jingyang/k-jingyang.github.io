---
layout: post
title:  "Understanding TLS"
date:   2020-12-12 14:00:00 +0800
categories: tls 
---

### Why
The concept of TLS/SSL has always escaped me, so I decided to take the time to understand it and to write about it. Many thanks to a friend for always entertaining my questions.  

### TLS vs SSL
Both TLS and SSL are used to secure internet communications. So why are there two? TLS is just the updated version of the now deprecated SSL. TLS will be the focal point of this blog post. 

### TLS
TLS secures a connection. An example of a secured connection would be HTTPS; HTTPS is just HTTP secured with TLS.

When a connection wants to be encrypted and secured using TLS, *something* needs to initialize in order to secure the connection. This *something* refers to a TLS handshake. 

> What is a secured connection? A connection is secured where both parties involved in the communication **agrees on a method to encrypt and decrypt information** and other parties are not privy to this. In the case of a TLS connection, both parties have to agree on a key to encrypt the decrypt communications. The TLS handshake helps to facilitate this. 

### TLS Handshake
All the jargons on TLS like public keys, private keys, certificates that we often hear about are ingredients necessary for the TLS handshake to occur.

Although the following is not the most comprehensive and detailed description of the handshake process, it seeks to capture the most important areas of it. 

1. Client (e.g. a web browser) tries to establish a connection to the server. It sends a client random (32-byte random number), the TLS version it can support, and other metadata to the server
1. Server sends back a server random, and its [certificate](#certificate) (this also contains the public key of the server)
1. Client verifies the certificate against its CA certs store (which contains recognized CA certificates). This is to determine if the server's certificate was issued by a trusted certificate authority (CA) 
1. After verifying the certificate, the client uses the public key (in the certificate) to encrypt a pre-master secret and sends it to the server
1. Server receives the encrypted pre-master secret and decrypts it with its private key
1. Both server and client generates a symmetric key using the server random, client random and the pre-master key
1. Client and server can now encrypt messages using the generated symmetric key

### Public Key & Private Key
In the past, I used to believe that a public key can only encrypt while a private key can only decrypt. This is a big misconception. 

When an asymmetric keypair *k1*, *k2* is generated (in the case of RSA). Mathematically, we can use *k1* to encrypt and only *k2* can be used to decrypt. Conversely, when we use *k2* to encrypt, we can only use *k1* to decrypt. It's our choice whether to use *k1* or *k2* as the public or private key. 

In use cases where we want only the recipient to read the content of a message, we select a key (from the keypair, owned by the recipient) to be used to decrypt the content and keep this key private to the recipient. Hence the name, private key. To allow senders to send encrypted messages to the recipient, the other key (from the keypair, owned by the recipient) has to be distributed publicly, hence the name, public key. 

That is not to say that the key chosen to be the private key can only be used for decryption. An entity (let's use Alice) can use their private key to encrypt some metadata which can only be decrypted with its corresponding public key (which is known by everybody). By the act of successfully decrypting using the public key and assuming that no one else is supposed to be privy to the private key, we can verify that the metadata came from Alice. If the metadata contains the cryptographic hash of a message, we could even use this to verify that the message hasn't been tampered with. The act of using the private key to encrypt some metadata for the purpose verification is also known as **signing**

### Certificate
In the TLS handshake, we noticed that the server sends its certificate to the client. What's a certificate and how does the server gets one?

A certificate contains the public key and information of its holder and the certificate authority (CA) who issued the cert. How can we verify that the cert was indeed issued by the certificate authority? Let use what we know now about [signing](#public-key--private-key). The certificate was signed by the CA using their private key when issuing it, so we can verify this by using the CA's public key, which is housed inside our certificate store. 

To get a CA to issue you a certificate, we have to submit a certificate signing request (CSR) to the CA. The CSR will have to include information about your business and the public key you would like to include in the issued certificate. An underlying assumption here is that a CA will only issue a certificate after checking that the business entity (or individual) is legitimate.

### Conclusion
Hope that I've given anybody who reads this post a better understanding of TLS. Many concepts were unclear to me at first, but writing this has allowed me to plug most of the gap when it comes to my knowledge of TLS. There're still concepts that are foreign (e.g. the math behind asymmetric keys), but this is enough for me now. Cheers!

### References
<https://www.cloudflare.com/en-ca/learning/ssl/what-happens-in-a-tls-handshake/>\
<https://www.youtube.com/watch?v=86cQJ0MMses>\
<https://en.wikipedia.org/wiki/Public_key_certificate>\
<https://www.globalsign.com/en-sg/blog/what-is-a-certificate-signing-request-csr>


