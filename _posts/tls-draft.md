---
layout: post
title:  ""
date:   2020-11-10 14:00:00 +0800
categories: tls 
---

### Preface
The concept of TLS/SSL has always escaped me, so I decided to take the time to understand it and to write about it. Many thanks to a friend for always entertaining my questions.  

### TLS vs SSL
Both TLS and SSL are used to secure internet communications. So why are there two? TLS is just the updated version of the now deprecated SSL. TLS will be the focal point of this blog post. 

### TLS
TLS secures a connection. An example of a secured connection would be HTTPS; HTTPS is just HTTP secured with TLS.

When a connection wants to be encrypted and secured using TLS, *something* needs to initialize in order to secure the connection. This *something* refers to a TLS handshake. 

> What is meant by a secured connection? A connection is secured where both parties involved in the communication **agrees on a key to be used to encrypt and decrypt information (i.e. a symmetric key)** and other parties are not privy to this. The TLS handshakes helps to facilitate this. 

### TLS Handshake
All the jargons on TLS like public keys, private keys, certificates that we often hear about are ingredients necessary for the TLS handshake to occur.

The following is not the most comprehensive and detailed description of the handshake process, but it seeks to capture the most important areas of it. 

1. Client (e.g. a web browser) tries to establish a connection to the server. It sends a client random (32-byte random number), the TLS version it can support, and other metadata to the server
1. Server sends back a server random, and a [certificate](certificate) (it also contains the public key of the server)
1. Client verifies the certificate against its CA certs store (which contains recognized root CA certs). This is to determine if the server's certificate was generated by a trusted CA
1. After verifying the certificate, the client uses the public key (in the certificate) to encrypt a pre-master secret and sends it to the server
1. Server receives the encrypted pre-master secret and decrypts it with its private key
1. Both server and client generates a symmetric key using the server random, client random and the pre-master key
1. Client and server can now encrypt messages using the said symmetric key

### Certificate
*Detail about CSR*

An underlying assumption is that a CA will only create a certificate after checking that the business enity (or individual) behind the server is legitimate.

Bold **signs** and **encrypts**

*Detail about signing vs encryption*

### Public Key & Private Key
In the past, I used to believe that a public key can only encrypt while a private key can only decrypt. I had a misconception of this, and cannot be more wrong. 

> When an asymmetric keypair *k1*, *k2* is generated (in the case of RSA). Mathematically, we can use *k1* to encrypt and only *k2* can be used to decrypt this. Conversely, when we use *k2* to encrypt, we can only use *k1* to decrypt. It's our choice whether to use *k1* or *k2* as the public or private key. 

In use cases where we want only the recipient to read the content of a message, we select a key (from the keypair, owned by the recipient) to be used to decrypt the content and keep this key private to the recipient. Hence the name, private key. To allow senders to send encrypted messages to the recipient, the other key (from the keypair, owned by the recipient) has to be distributed publicly, hence the name, public key. 

That is not to say that the key chosen to be the private key can only be used for decryption. The recipient can use their private key to encrypt some metadata. This encrypted information can only be decrypted with its corresponding public key (which is known by everybody). This mechanism allows any sender to verify the authenticity of the recipient.



### References
https://www.youtube.com/watch?v=86cQJ0MMses

